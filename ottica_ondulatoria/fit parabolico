#include <iostream>
#include <vector>
#include <cmath>
#include <fstream>
#include <iomanip>
int main()
{
    // ======================
    // DATI USATI NEL FIT
    // ======================
    std::vector<double> theta = {
        -46, -36, -26, -16, -6, -4, 0, 4, 14, 24, 34, 44, 54



    };

    std::vector<double> I = {
    38067099, 30491864, 22559308, 14242088, 5107512, 2929815, 2468308, 4206631, 12439564, 21911187, 30332525, 37593974, 43087740
 

    };

    const int N = theta.size();
// ======================
    // TROVO IL MINIMO APPROSSIMATIVO
    // ======================
    double I_min = std::numeric_limits<double>::max();
    double theta_min = 0;

    for (int i = 0; i < N; i++)
    {
        if (I[i] < I_min)
        {
            I_min = I[i];
            theta_min = theta[i];
        }
    }

    // ======================
    // SELEZIONE PUNTI VICINI AL MINIMO
    // Definire un intorno di ±10° attorno al minimo (modificabile)
    // ======================
    double delta_theta = 10.0; // intorno di selezione
    std::vector<double> theta_local;
    std::vector<double> I_local;

    for (int i = 0; i < N; i++)
    {
        if (std::abs(theta[i] - theta_min) <= delta_theta)
        {
            theta_local.push_back(theta[i]);
            I_local.push_back(I[i]);
        }
    }

    int N_local = theta_local.size();

    // ======================
    // SOMMATORIE PER FIT PARABOLICO LOCALE
    // ======================
    double Sx=0, Sx2=0, Sx3=0, Sx4=0;
    double Sy=0, Sxy=0, Sx2y=0;

    for (int i = 0; i < N_local; i++)
    {
        double x = theta_local[i];
        double y = I_local[i];

        Sx   += x;
        Sx2  += x*x;
        Sx3  += x*x*x;
        Sx4  += x*x*x*x;

        Sy   += y;
        Sxy  += x*y;
        Sx2y += x*x*y;
    }

    // ======================
    // RISOLUZIONE SISTEMA LINEARE 3x3
    // ======================
    double D =
        Sx4*(Sx2*N_local - Sx*Sx) -
        Sx3*(Sx3*N_local - Sx*Sx2) +
        Sx2*(Sx3*Sx - Sx2*Sx2);

    double DA =
        Sx2y*(Sx2*N_local - Sx*Sx) -
        Sx3*(Sxy*N_local - Sx*Sy) +
        Sx2*(Sxy*Sx - Sx2*Sy);

    double DB =
        Sx4*(Sxy*N_local - Sx*Sy) -
        Sx2y*(Sx3*N_local - Sx*Sx2) +
        Sx2*(Sx3*Sy - Sx2*Sxy);

    double DC =
        Sx4*(Sx2*Sy - Sx*Sxy) -
        Sx3*(Sx3*Sy - Sx2*Sxy) +
        Sx2y*(Sx3*Sx - Sx2*Sx2);

    double A = DA / D;
    double B = DB / D;
    double C = DC / D;

    // ======================
    // POSIZIONE DEL MINIMO LOCALE
    // ======================
    double theta_min_fit = -B / (2*A);

    // ======================
    // CONVERSIONE AL MINIMO ASSOLUTO (RISPETTO AL TUO ZERO A 60°)
    // ======================
    double theta_min_assoluto = 60 + theta_min_fit;

    // ======================
    // OUTPUT A SCHERMO
    // ======================
    std::cout << "Fit parabolico locale:\n";
    std::cout << "A = " << A << "\n";
    std::cout << "B = " << B << "\n";
    std::cout << "C = " << C << "\n\n";

    std::cout << "Minimo relativo (theta): " << theta_min_fit << " deg\n";
    std::cout << "Minimo assoluto rispetto a 60°: " << theta_min_assoluto << " deg\n";
    std::cout << "Intensità minima stimata: " << A*theta_min_fit*theta_min_fit + B*theta_min_fit + C << "\n";

    // ======================
    // FILE DI OUTPUT PER GNUPLOT
    // ======================
    double theta_plot_min = theta_min - delta_theta;
    double theta_plot_max = theta_min + delta_theta;
    double step = 0.01;

    std::ofstream fout("parabola_fit.dat");
    fout << "# theta    I_fit\n";

    for (double th = theta_plot_min; th <= theta_plot_max; th += step)
    {
        double I_fit = A*th*th + B*th + C;
        fout << std::fixed << std::setprecision(6) << th << " " << I_fit << "\n";
    }

    fout.close();

    std::cout << "\nFile 'parabola_fit.dat' generato per Gnuplot.\n";

    return 0;
}

